package numtheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * Various number theory utilities. Including, but not limited to,
 * congruence, prime numbers.
 */
public class Util {
  // Holds a list of pre-generated prime numbers
  private static int[] primes;
  // Holds an Eratosthenes' sieve of some amount of numbers
  private static boolean[] sieve;

  private Util() {}

  /**
   * Generates a prime sieve from zero up to the num-1th number. Used for rapid primality testing.
   * @param num Number to generate all prime numbers below.
   */
  public static void generateSieve(int num) {
    if(num > Integer.MAX_VALUE / 2) {
      throw new IllegalArgumentException("Requested a generation of too big a prime sieve.");
    }

    sieve = new boolean[num];
    Arrays.fill(sieve, true);
    // 0 and 1 aren't prime numbers (probably)
    sieve[0] = false;
    sieve[1] = false;

    // Starting with two, loop through all possible prime candidates smaller than num
    for(int i = 2; i < Math.sqrt(num) + 1; ++i) {
      if(sieve[i]) {
        // Sieve out all multiples of the prime number
        for(int multiple = i*i; multiple < num; multiple += i) {
          sieve[multiple] = false;
        }
      }
    }

    List<Integer> primesLis = new ArrayList<>();
    for(int i = 1; i < sieve.length; ++i) {
      if(sieve[i]) {
        primesLis.add(i);
      }
    }
    primes = primesLis.stream().mapToInt(Integer::intValue).toArray();
  }

  /**
   * Returns an array of all the {@code from}<sup>th</sup> - {@code to}<sup>th</sup> primes.
   * Note that this array is a copy.
   *
   * @param from Where to start returning prime numbers (e.g. 2 is the first, 3 is the second, etc)
   * @param to Where to top returning prime numbers
   * @return An array of prime numbers
   */
  public static int[] getPrimes(int from, int to) {
    if(primes == null || to >= primes.length) {
      throw new IllegalStateException(
              "Not enough pre-generated primes. Try calling generateSieve() first.");
    }
    return Arrays.copyOfRange(primes, from, to);
  }

  /**
   * Returns all the primes generated by {@code Util}.
   *
   * @return An array of prime numbers.
   */
  public static int[] getPrimes() {
    if(primes == null) {
      throw new IllegalStateException("Asked for prime numbers before prime number lookup table" +
              "generated");
    }
    return primes;
  }

  /**
   * Returns the prime number sieve generated by {@code Util}.
   *
   * @return Boolean array containing true if the index is prime, false otherwise. Starts at zero
   */
  public static boolean[] getSieve() {
    if(sieve == null) {
      throw new IllegalStateException("Sieve never initialized. Call generateSieve");
    }
    return sieve;
  }

  /**
   * Returns true if num1 === num2 (mod m).
   *
   * @param num1 First number to test congruence
   * @param num2 Number to test congruence of first number with
   * @param modulo Modulus of congruence
   * @return True if num1 === num2 (mod m), false if not
   */
  public static boolean isCongruent(int num1, int num2, int modulo) {
    return ((num1 % modulo) == num2);
  }

  /**
   * Returns the prime factorization of a number with no repeats of duplicate prime factors.
   * Negative numbers may not be factored, nor may zero. 1 has no factors.
   *
   * @param number Number to factorize
   * @return Set of prime factors of the number
   * @throws IllegalStateException if the prime sieve is not big enough
   * @throws IllegalArgumentException if given zero or a negative number to factor
   */
  public static Set<Integer> factorNoRepeats(int number) {
    return factor(number).stream().map((fac) -> fac.prime).collect(Collectors.toSet());
  }

  /**
   * Factors a number, combining repeats into a container called {@code Factor}.
   *
   * @param number Number to factor
   * @return Set of {@code Factor}s
   * @throws IllegalStateException if the prime sieve is not big enough
   * @throws IllegalArgumentException if given zero or a negative number to factor
   */
  public static Set<Factor> factor(int number) {
    factorCheck(number);

    Set<Factor> ans = new HashSet<>();
    for(int i = 0; i < primes.length && number != 1; ++i) {
      if(number % primes[i] == 0) {
        int numFac = 0;
        while(number % primes[i] == 0) {
          numFac++;
          number /= primes[i];
        }
        ans.add(new Factor(primes[i], numFac));
      }
    }
    return ans;
  }

  /**
   * Returns whether a natural number is prime or not.
   *
   * @param number Number to test primality of
   * @return True if the number is prime, false if not
   * @throws IllegalArgumentException If given a negative number
   * @throws IllegalStateException If the prime sieve is null/not big enough
   */
  public static boolean isPrime(int number) {
    if(number < 0) {
      throw new IllegalArgumentException("Given a negative number");
    }

    if(sieve == null || number >= sieve.length-1) {
      throw new IllegalStateException("Need to generate a larger sieve first");
    }

    return sieve[number];
  }


  /**
   * Calculates the radical of a number. When considering the prime factorization of a number,
   * the radical is the number that results when all duplicate primes are removed.
   * <p>Example: 3780 = 2*2*3*3*3*5*7, rad(3780) = 2*3*5*7 = 210.
   *
   * @param number Number to calculate the radical of
   * @return Radical of the given number
   * @throws IllegalStateException If prime sieve is not big enough
   * @throws IllegalArgumentException If given 0 or a negative number
   */
  public static int radical(int number) {
    // muh java 8
    return factorNoRepeats(number).stream().reduce(1, (x, y) -> x * y);
  }

  /**
   * Calculates the Euler totient function of the given number. The totient function is defined as
   * the count of relatively prime positive integers less than a number.
   *
   * @param number Number to calculate totient of
   * @return phi(number)
   * @throws IllegalStateException If prime sieve is not big enough
   * @throws IllegalArgumentException If given 0 or a negative number
   */
  public static int phi(int number) {
    if(number == 1) {
      return 1;
    }

    return factor(number).stream().reduce(1,
            // Basically a fold op, uses fact that phi(mn) = phi(m)phi(n) if GCD(m,n) = 1,
            // and that phi(p^k) = p^k - p^(k-1)
            (acc, fact) ->
                    // Take the current value of the accumulator and multiply it by the next phi
                    // of a prime
                   acc * (fact.expPrime() - fact.expPrime() / fact.prime),
            // I don't understand why I need this third lambda, but its value doesn't seem to matter
            // and not having some lambda here confuses java. Ergo, I just map to 1.
            (x, y) -> 1);
  }

  /**
   * Uses the Euclidean algorithm to determine the greatest common divisor of two numbers.
   * The greatest common divisor of two numbers is the largest number that divides both numbers.
   *
   * @param num1 First number
   * @param num2 Second number
   * @return The largest number that divides both arguments
   */
  public static int gcd(int num1, int num2) {
    if(num1 < num2) {
      int temp = num1;
      num1 = num2;
      num2 = temp;
    }

    // Euclidean algorithm
    int currRem = num2;
    while(num1 % num2 != 0) {
      currRem = num1 % num2;
      num1 = num2;
      num2 = currRem;
    }
    return currRem;
  }

  /**
   * Returns a set that forms a reduced residue system modulo a given number.
   * More simply, it returns all numbers that are both smaller and relatively prime
   * to the given number.
   *
   * @param num Modulus for the reduced residue system
   * @return Set of numbers that form a reduced residue system
   */
  public static SortedSet<Integer> getReducedResidueSystem(int num) {
    SortedSet<Integer> ans = new TreeSet<>();
    for(int i = 1; i < num; ++i) {
      if(Util.gcd(num, i) == 1) {
        ans.add(i);
      }
    }
    return ans;
  }


  /**
   * Calculates the divisor function of a given number.
   * That is, the sum of all d &lt; n that divide n, including n.
   *
   * @param number Number to calculate sigma of
   * @return sigma(number)
   */
  public static int sigma(int number) {
    if(number == 1) {
      return 1;
    }

    return factor(number).stream().reduce(1,
            // Uses the fact that sigma(mn) = sigma(m)sigma(n) when GCD(m,n) = 1,
            // and that sigma(p^k) = (p^(k+1) - 1) / (p - 1)
            (acc, fact) ->
                    // Take the current value of the accumulator and multiply it by the next sigma
                    // of a prime
                    acc * (fact.expPrime() * fact.prime - 1) / (fact.prime - 1),
            // Same as in phi(), not sure why it be like it is, but it do
            (x, y) -> 1);
  }

  /**
   * Basic error checking for factoring functions.
   *
   * @param number Potential number to be factored
   * @throws IllegalArgumentException If the number is 0 or negative
   * @throws IllegalStateException If the prime sieve is not big enough
   */
  private static void factorCheck(int number) {
    if(primes == null || primes[primes.length-1] < Math.sqrt(number)) {
      throw new IllegalStateException("Need to increase size of sieve");
    }

    if(number == 0) {
      throw new IllegalArgumentException("Zero has an infinite number of factors");
    } else if (number < 0) {
      throw new IllegalArgumentException("Cannot factor a negative number");
    }
  }

  /**
   * Represents a factor of some number, which is some prime and the number of times it is a factor.
   */
  public static class Factor {
    public final int prime;
    public final int exponent;

    /**
     * Create a factor with a given prime value and exponent.
     *
     * @param prime The prime number that represents the factor
     * @param exponent The number of times the prime number occurs
     */
    Factor(int prime, int exponent) {
      this.prime = prime;
      this.exponent = exponent;
    }

    /**
     * Exponents the prime held by this {@code Factor} by the exponent held.
     *
     * @return prime<sup>exponent</sup>
     */
    int expPrime() {
      return (int)Math.pow(prime, exponent);
    }

    @Override
    public int hashCode() {
      return Objects.hash(prime, exponent);
    }

    /**
     * Two {@code Factor}s are equal if their prime and exponents are equal.
     *
     * @param other Object to compare to this {@code Factor}
     * @return True if other is equal to this {@code Factor}, false otherwise
     */
    @Override
    public boolean equals(Object other) {
      if(!(other instanceof Factor)) {
        return false;
      }

      final Factor otherFac = (Factor)other;

      return otherFac.exponent == this.exponent && otherFac.prime == this.prime;
    }

    @Override
    public String toString() {
      return Integer.toString(prime) + "^" + Integer.toString(exponent);
    }
  }
}
