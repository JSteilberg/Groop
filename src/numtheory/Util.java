package numtheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Various number theory utilities. Including, but not limited to,
 * congruence, prime numbers.
 */
public class Util {
  // Holds a list of pre-generated prime numbers
  private static int[] primes;
  // Holds an Eratosthenes' sieve of some amount of numbers
  private static boolean[] sieve;

  private Util() {}

  /**
   * Generates a prime sieve from zero up to the num-1th number. Used for rapid primality testing.
   * @param num Number to generate all prime numbers below.
   */
  public static void generateSieve(int num) {
    if(num > Integer.MAX_VALUE / 2) {
      throw new IllegalArgumentException("Requested a generation of too big a prime sieve.");
    }

    sieve = new boolean[num];
    Arrays.fill(sieve, true);
    // 0 and 1 aren't prime numbers (probably)
    sieve[0] = false;
    sieve[1] = false;

    // Starting with two, loop through all possible prime candidates smaller than num
    for(int i = 2; i < Math.sqrt(num) + 1; ++i) {
      if(sieve[i]) {
        // Sieve out all multiples of the prime number
        for(int multiple = i*i; multiple < num; multiple += i) {
          sieve[multiple] = false;
        }
      }
    }

    List<Integer> primesLis = new ArrayList<>();
    for(int i = 1; i < sieve.length; ++i) {
      if(sieve[i]) {
        primesLis.add(i);
      }
    }
    primes = primesLis.stream().mapToInt(Integer::intValue).toArray();
  }

  /**
   * Returns an array of all the {@code from}<sup>th</sup> - {@code to}<sup>th</sup> primes/
   * Note that this array is a copy.
   *
   * @param from Where to start returning prime numbers (e.g. 2 is the first, 3 is the second, etc)
   * @param to Where to top returning prime numbers
   * @return An array of prime numbers
   */
  public static int[] getPrimes(int from, int to) {
    if(primes == null || to >= primes.length) {
      throw new IllegalStateException(
              "Not enough pre-generated primes. Try calling generateSieve() first.");
    }
    return Arrays.copyOfRange(primes, from, to);
  }

  /**
   * Returns all the primes generated by {@code Util}.
   *
   * @return An array of prime numbers.
   */
  public static int[] getPrimes() {
    if(primes == null) {
      throw new IllegalStateException("Asked for prime numbers before prime number lookup table" +
              "generated");
    }
    return primes;
  }

  /**
   * Returns the prime number sieve generated by {@code Util}.
   *
   * @return Boolean array containing true if the index is prime, false otherwise. Starts at zero
   */
  public static boolean[] getSieve() {
    if(sieve == null) {
      throw new IllegalStateException("Sieve never initialized. Call generateSieve");
    }
    return sieve;
  }

  /**
   * Returns true if num1 === num2 (mod m).
   *
   * @param num1 First number to test congruence
   * @param num2 Number to test congruence of first number with
   * @param modulo Modulus of congruence
   * @return True if num1 === num2 (mod m), false if not
   */
  public static boolean isCongruent(int num1, int num2, int modulo) {
    return ((num1 % modulo) == num2);
  }

  /**
   * Returns the prime factorization of a number with no repeats of duplicate prime factors.
   * Negative numbers may not be factored, nor may zero. 1 has no factors.
   *
   * @param number Number to factorize
   * @return Set of prime factors of the number
   * @throws IllegalStateException if the prime sieve is not big enough
   * @throws IllegalArgumentException if given zero or a negative number to factor
   */
  public static Set<Integer> factorNoRepeats(int number) {
    factorCheck(number);

    Set<Integer> ans = new HashSet<>();

    for(int i = 0; i < primes.length && number != 1; ++i) {
      if(number % primes[i] == 0) {
        ans.add(primes[i]);
        number /= primes[i];
      }
    }
    return ans;
  }

  /**
   * Factors a number, combining repeats into a container called {@code Factor}.
   *
   * @param number Number to factor
   * @return Set of {@code Factor}s
   * @throws IllegalStateException if the prime sieve is not big enough
   * @throws IllegalArgumentException if given zero or a negative number to factor
   */
  public static Set<Factor> factor(int number) {
    factorCheck(number);

    Set<Factor> ans = new HashSet<>();
    for(int i = 0; i < primes.length && number != 1; ++i) {
      if(number % primes[i] == 0) {
        int numFac = 0;
        while(number % primes[i] == 0) {
          numFac++;
          number /= primes[i];
        }
        ans.add(new Factor(primes[i], numFac));
      }
    }
    return ans;
  }

  /**
   * Basic error checking for factoring functions
   *
   * @param number Potential number to be factored
   * @throws IllegalArgumentException If the number is 0 or negative
   * @throws IllegalStateException If the prime sieve is not big enough
   */
  private static void factorCheck(int number) {
    if(primes == null || primes[primes.length-1] < Math.sqrt(number)) {
      throw new IllegalStateException("Need to increase size of sieve");
    }

    if(number == 0) {
      throw new IllegalArgumentException("Zero has an infinite number of factors");
    } else if (number < 0) {
      throw new IllegalArgumentException("Could not factor a negative number");
    }
  }

  /**
   * Represents a factor of some number, which is some prime and the number of times it is a factor.
   */
  public static class Factor {
    final int prime;
    final int exponent;

    /**
     * Create a factor with a given prime value and exponent.
     *
     * @param prime The prime number that represents the factor
     * @param exponent The number of times the prime number occurs
     */
    Factor(int prime, int exponent) {
      this.prime = prime;
      this.exponent = exponent;
    }

    @Override
    public int hashCode() {
      return Objects.hash(prime, exponent);
    }

    /**
     * Two {@code Factor}s are equal if their prime and exponents are equal.
     *
     * @param other Object to compare to this {@code Factor}
     * @return True if other is equal to this {@code Factor}, false otherwise
     */
    @Override
    public boolean equals(Object other) {
      if(!(other instanceof Factor)) {
        return false;
      }

      final Factor otherFac = (Factor)other;

      return otherFac.exponent == this.exponent && otherFac.prime == this.prime;
    }

    @Override
    public String toString() {
      return Integer.toString(prime) + "^" + Integer.toString(exponent);
    }
  }
}
